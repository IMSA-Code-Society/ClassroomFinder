<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="stylesheet" href="/home.css">
    <meta charset="UTF-8">
    <div class="map">
        <img class="hallway" src="/image">
        <canvas width="1029" height="1182"> </canvas>
    </div>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schedule Input</title>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Script loaded'); // Confirm script loading

            let canvas = document.getElementsByTagName("canvas")[0];
            let context = canvas.getContext("2d");
            const circles = [];
            let paths = [];

            document.getElementById('scheduleForm').addEventListener('submit', function (e) {
                e.preventDefault(); // Prevent the default form submission action
                console.log('Form submitted'); // Confirm form submission is intercepted

                const scheduleInput = document.getElementById('scheduleInput').value;
                const pathOutput = document.getElementById('pathOutput');
                const errorOutput = document.getElementById('errorOutput');
                const selectedDay = document.getElementById('daySelector').value;

                let colorMap = {
                    0: "red",
                    1: "orange",
                    2: "yellow",
                    3: "green",
                    4: "blue",
                    5: "purple",
                    6: "pink",
                    7: "black",
                };

                circles.length = 0; // Clear any previous circles
                paths = []; // Clear any previous paths

                try {
                    fetch("/schedule-post", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify({
                            "Schedule Input": scheduleInput,
                        }),
                    })
                        .then((data) => data.json())
                        .then((json) => {
                            console.log("Received JSON:", json);
                            if (json.status == 1) {
                                console.log("Couldn't get path sorry :I");
                                return;
                            }
                            const xShift = 4; // Shift in the x direction
                            const yShift = 4; // Shift in the y direction

                            context.clearRect(0, 0, canvas.width, canvas.height);

                            let curday = json[selectedDay];
                            curday.forEach((path, curnum) => {
                                const pathPoints = [];
                                for (let i = 1; i < path.length; i++) {
                                    const startX = path[i - 1]["x"] + curnum * xShift;
                                    const startY = path[i - 1]["y"] + curnum * yShift;
                                    const endX = path[i]["x"] + curnum * xShift;
                                    const endY = path[i]["y"] + curnum * yShift;

                                    context.beginPath();
                                    context.moveTo(startX, startY);
                                    context.lineTo(endX, endY);
                                    context.strokeStyle = colorMap[curnum];
                                    context.lineWidth = 3;
                                    context.stroke();
                                    context.closePath();

                                    // Store the path points for redrawing later
                                    pathPoints.push({ startX, startY, endX, endY, color: colorMap[curnum] });

                                    // Draw a small circle at the starting point where the line changes direction
                                    context.beginPath();
                                    context.arc(startX, startY, 5, 0, 2 * Math.PI, false);
                                    context.fillStyle = colorMap[curnum];
                                    context.fill();
                                    context.closePath();

                                    // Store circle data
                                    circles.push({
                                        x: startX,
                                        y: startY,
                                        radius: 4,
                                        name: path[i - 1]["name"],
                                        color: colorMap[curnum],
                                    });
                                }

                                // Draw a small circle at the final point of the path
                                const finalX = path[path.length - 1]["x"] + curnum * xShift;
                                const finalY = path[path.length - 1]["y"] + curnum * yShift;

                                context.beginPath();
                                context.arc(finalX, finalY, 5, 0, 2 * Math.PI, false);
                                context.fillStyle = colorMap[curnum];
                                context.fill();
                                context.closePath();

                                // Store final circle data
                                circles.push({
                                    x: finalX,
                                    y: finalY,
                                    radius: 4,
                                    name: path[path.length - 1]["name"],
                                    color: colorMap[curnum],
                                });

                                // Store the final point of the path for redrawing
                                pathPoints.push({ startX: finalX, startY: finalY, endX: finalX, endY: finalY, color: colorMap[curnum] });

                                // Save the entire path for later redrawing
                                paths.push(pathPoints);
                            });
                        })
                        .catch((err) => {
                            console.log("Fetch error:", err);
                        });
                } catch (error) {
                    errorOutput.innerHTML = `Error: ${error.message}`;
                    pathOutput.innerHTML = ''; // Clear any previous path
                }
            });

            // Add a mousemove event listener to the canvas to detect hover
            canvas.addEventListener('mousemove', function (e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width; // Calculate the scale factor for X
                const scaleY = canvas.height / rect.height; // Calculate the scale factor for Y
                const mouseX = (e.clientX - rect.left) * scaleX; // Adjust mouse X based on the scaling
                const mouseY = (e.clientY - rect.top) * scaleY;   // Adjust mouse Y based on the scaling

                context.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
                redrawPaths(); // Redraw the paths and circles

                circles.forEach(circle => {
                    if (isMouseOverCircle(mouseX, mouseY, circle)) {
                        context.font = "28px Arial";
                        context.fillStyle = circle.color;

                        context.fillText(circle.name, circle.x + 10, circle.y + 5); // Display the name when hovering
                    }
                });
            });

            // Function to check if the mouse is over a circle
            function isMouseOverCircle(mouseX, mouseY, circle) {
                const distance = Math.sqrt((mouseX - circle.x) ** 2 + (mouseY - circle.y) ** 2);
                return distance <= circle.radius;
            }

            // Function to redraw paths and circles after clearing the canvas
            function redrawPaths() {
                paths.forEach(path => {
                    path.forEach(segment => {
                        context.beginPath();
                        context.moveTo(segment.startX, segment.startY);
                        context.lineTo(segment.endX, segment.endY);
                        context.strokeStyle = segment.color;
                        context.lineWidth = 3;
                        context.stroke();
                        context.closePath();
                    });
                });

                circles.forEach(circle => {
                    context.beginPath();
                    context.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI, false);
                    context.fillStyle = circle.color;
                    context.fill();
                    context.closePath();
                });
            }
        });
    </script>

</head>

<body style="background-color:rgb(107, 130, 172)" ;>
    <div style="background-color:darkcyan; text-align: center;">
        <form id="scheduleForm">
            <textarea id="scheduleInput" placeholder="Enter schedule..." rows="10%" cols="150%"
                style="background-color:rgb(85, 87, 137)" ;></textarea>
            <p></p>
            <div style="display: flex; justify-content: center; align-items: center; gap: 20px; margin-top: 10px;">
                <label for="daySelector">Choose a day to render:</label>
                <select id="daySelector">
                    <option value="aday">A Day</option>
                    <option value="bday">B Day</option>
                    <option value="cday">C Day</option>
                    <option value="dday">D Day</option>
                    <option value="iday">I Day</option>
                </select>
                <button type="submit">Submit</button>
                <div style="display: flex; flex-direction: column; align-items: flex-start;">
                    <p><a href="/">Schedule Finder</a>
                        <a href="/about">About Page</a>
                        <a href="/path">Direct Path</a>
                    </p>
                </div>
            </div>
    </div>
</body>

</html>